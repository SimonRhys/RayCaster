#version 430 core
#define MAX_SCENE_BOUNDS 100.0

struct box {
  vec3 min;
  vec3 max;
};

struct hitinfo {
  vec2 lambda;
  vec3 boxMin;
  vec3 boxMax;
  int bi;
};

struct Tri {
	vec3 p1;
	vec3 p2;
	vec3 p3;
	vec3 norm;
};

uniform vec3 eye;
uniform vec3 ray00;
uniform vec3 ray01;
uniform vec3 ray10;
uniform vec3 ray11;
uniform vec3 lightPos;
uniform int NUM_BOXES;

layout(binding = 0, rgba32f) uniform image2D framebuffer;
layout(std430) buffer boxes {
	 box data[];
};
layout(std430) buffer triangles {
	Tri triData;
};

float triEdgeCheck(vec3 v1, vec3 v2, vec3 plane, vec3 norm)
{
	vec3 edge = v2 - v1;
	vec3 vp = plane - v1;

	//Vector perpendicular to plane
	vec3 c = cross(edge, vp);

	return dot(norm, c);
}

bool intersectTri(vec3 origin, vec3 dir, const Tri tri)
{
	//Check if ray and plane are parallel
	float normRayDir = abs(dot(tri.norm, dir));
	if(normRayDir < 0.001)
	{
		return false;
	}

	float d = dot(tri.norm, tri.p1);
	float t = (dot(tri.norm, origin) + d) / normRayDir;

	//Triangle is behind ray
	if(t < 0)
	{
		return false;
	}

	vec3 intersectPlane = origin + t * dir;

	//P is on the right side
	if(triEdgeCheck(tri.p1, tri.p2, intersectPlane, tri.norm) < 0)
	{
		return false;
	}

	//P is on the right side
	if(triEdgeCheck(tri.p2, tri.p3, intersectPlane, tri.norm) < 0)
	{
		return false;
	}

	//P is on the right side
	if(triEdgeCheck(tri.p3, tri.p1, intersectPlane, tri.norm) < 0)
	{
		return false;
	}
	

	return true;

}

vec2 intersectBox(vec3 origin, vec3 dir, const box b) {
  vec3 tMin = (b.min - origin) / dir;
  vec3 tMax = (b.max - origin) / dir;
  vec3 t1 = min(tMin, tMax);
  vec3 t2 = max(tMin, tMax);
  float tNear = max(max(t1.x, t1.y), t1.z);
  float tFar = min(min(t2.x, t2.y), t2.z);
  return vec2(tNear, tFar);
}

bool intersectBoxes(vec3 origin, vec3 dir, out hitinfo info) {
  float smallest = MAX_SCENE_BOUNDS;
  bool found = false;
  for (int i = 0; i < NUM_BOXES; i++) {
    vec2 lambda = intersectBox(origin, dir, data[i]);
    if (lambda.x > 0.0 && lambda.x < lambda.y && lambda.x < smallest) {
      info.lambda = lambda;
      info.bi = i;
	  info.boxMin = data[i].min;
	  info.boxMax = data[i].max;
      smallest = lambda.x;
      found = true;
    }
  }
  return found;
}
vec4 trace(vec3 origin, vec3 dir) {
	hitinfo i;
	if (intersectBoxes(origin, dir, i)) 
	{
		vec3 intersect = origin + dir * i.lambda.x;
		vec3 minResult = abs(i.boxMin - intersect);
		vec3 maxResult = abs(i.boxMax - intersect);
		vec3 faceNormal = vec3(0, 0, 0);
		if(minResult.x < 0.01)
		{
			faceNormal = vec3(-1, 0, 0);
		}
		else if(minResult.y < 0.01)
		{
			faceNormal = vec3(0, -1, 0);
		}
		else if(minResult.z < 0.01)
		{
			faceNormal = vec3(0, 0, -1);
		}
		else if(maxResult.x < 0.01)
		{
			faceNormal = vec3(1, 0, 0);
		}
		else if(maxResult.y < 0.01)
		{
			faceNormal = vec3(0, 1, 0);
		}
		else if(maxResult.z < 0.01)
		{
			faceNormal = vec3(0, 0, 1);
		}
		else
		{
			return vec4(1, 1, 1, 1);
		}

		// Ambient
		vec3 lightColour = vec3(1, 1, 1);
		vec3 objectColour = vec3(1, 0, 0);
		float ambientStrength = 0.3f;
		vec3 ambient = ambientStrength * lightColour;

		// Diffuse 
		vec3 norm = normalize(faceNormal);
		vec3 lightDir = normalize(lightPos - intersect);
		float diff = max(dot(norm, lightDir), 0.0);
		vec3 diffuse = diff * lightColour;

		vec3 result = (ambient + diffuse) * objectColour;
		vec4 colour = vec4(result, 1.0f);

		return colour;
    
	}

	if(intersectTri(origin, dir, triData))
	{
		return vec4(0, 0, 1, 1);
	}

	return vec4(0.0, 0.0, 0.0, 1.0);
}

layout (local_size_x = 16, local_size_y = 8) in;
void main(void) {
	ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
	ivec2 size = imageSize(framebuffer);
	if (pix.x >= size.x || pix.y >= size.y) {
	return;
	}
	vec2 pos = vec2(pix) / vec2(size.x - 1, size.y - 1);
	vec3 dir = mix(mix(ray00, ray01, pos.y), mix(ray10, ray11, pos.y), pos.x);
	vec4 color = trace(eye, dir);
	imageStore(framebuffer, pix, color);
}
