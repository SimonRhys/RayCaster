#version 430 core
#define MAX_SCENE_BOUNDS 100.0

struct box {
  vec3 min;
  vec3 max;
};

struct hitinfo {
  vec2 lambda;
  vec3 boxMin;
  vec3 boxMax;
  int bi;
};

struct Tri {
	vec3 p0;
	vec3 p1;
	vec3 p2;
	vec3 norm;
};

uniform vec3 eye;
uniform vec3 ray00;
uniform vec3 ray01;
uniform vec3 ray10;
uniform vec3 ray11;
uniform vec3 lightPos;
uniform int NUM_BOXES;
uniform int NUM_TRIANGLES;

layout(binding = 0, rgba32f) uniform image2D framebuffer;
layout(std430) buffer boxes {
	 box data[];
};
layout(std430) buffer triangles {
	Tri triData[];
};

/*float intersectTri(vec3 origin, vec3 dir, const Tri tri)
{

	dir = -dir;
	vec3 v0v1 = tri.p1 - tri.p0;
	vec3 v0v2 = tri.p2 - tri.p0;
	vec3 n = cross(v0v1, v0v2);
	n = normalize(n);
	
	vec3 q = cross(v0v2, dir);
	float a = dot(v0v1, q);

	if(abs(a) <= 1e-8 ) return -1; //backfacing || dot(n, dir) >= 0

	vec3 s = (origin - tri.p0) / a;
	vec3 r = cross(s, v0v1);

	float b[3];
	b[0] = dot(s, q);
	b[1] = dot(r, dir);
	b[2] = 1 - b[0] - b[1];

	if(b[0] < 0 || b[1] < 0 || b[2] < 0) return -1;

	float t = dot(v0v2, r);

	return t;

}*/

float intersectTri(vec3 origin, vec3 dir, const Tri tri)
{
	vec3 v0v1 = tri.p1 - tri.p0;
	vec3 v0v2 = tri.p2 - tri.p0;
	vec3 pvec = cross(dir, v0v2);
	float det = dot(v0v1, pvec);

	if(abs(det) < 1e-8)
	{
		return -1;
	}

	float invDet = 1/det;

	vec3 tvec = origin - tri.p0;
	float u = dot(tvec, pvec) * invDet;
	if(u < 0 || u > 1)
	{
		return -1;
	}

	vec3 qvec = cross(tvec, v0v1);
	float v = dot(dir, qvec) * invDet;
	if(v < 0 || u + v > 1)
	{
		return -1;
	} 

	float t = dot(v0v2, qvec) * invDet;

	return t;

}

bool intersectTriangles(vec3 origin, vec3 dir, out float t)
{
	float smallest = MAX_SCENE_BOUNDS;
	bool found = false;
	for(int i=0; i < NUM_TRIANGLES; i++)
	{
		t = intersectTri(origin, dir, triData[i]);
		if( t >= 0 && t < smallest)
		{
			smallest = t;
			found = true;
		}
	}

	return found;
}

vec2 intersectBox(vec3 origin, vec3 dir, const box b) {
  vec3 tMin = (b.min - origin) / dir;
  vec3 tMax = (b.max - origin) / dir;
  vec3 t1 = min(tMin, tMax);
  vec3 t2 = max(tMin, tMax);
  float tNear = max(max(t1.x, t1.y), t1.z);
  float tFar = min(min(t2.x, t2.y), t2.z);
  return vec2(tNear, tFar);
}

bool intersectBoxes(vec3 origin, vec3 dir, out hitinfo info) {
  float smallest = MAX_SCENE_BOUNDS;
  bool found = false;
  for (int i = 0; i < NUM_BOXES; i++) {
    vec2 lambda = intersectBox(origin, dir, data[i]);
    if (lambda.x > 0.0 && lambda.x < lambda.y && lambda.x < smallest) {
      info.lambda = lambda;
      info.bi = i;
	  info.boxMin = data[i].min;
	  info.boxMax = data[i].max;
      smallest = lambda.x;
      found = true;
    }
  }
  return found;
}
vec4 trace(vec3 origin, vec3 dir) {
	hitinfo i;
	if (intersectBoxes(origin, dir, i)) 
	{
		vec3 intersect = origin + dir * i.lambda.x;
		vec3 minResult = abs(i.boxMin - intersect);
		vec3 maxResult = abs(i.boxMax - intersect);
		vec3 faceNormal = vec3(0, 0, 0);
		if(minResult.x < 0.01)
		{
			faceNormal = vec3(-1, 0, 0);
		}
		else if(minResult.y < 0.01)
		{
			faceNormal = vec3(0, -1, 0);
		}
		else if(minResult.z < 0.01)
		{
			faceNormal = vec3(0, 0, -1);
		}
		else if(maxResult.x < 0.01)
		{
			faceNormal = vec3(1, 0, 0);
		}
		else if(maxResult.y < 0.01)
		{
			faceNormal = vec3(0, 1, 0);
		}
		else if(maxResult.z < 0.01)
		{
			faceNormal = vec3(0, 0, 1);
		}
		else
		{
			return vec4(1, 1, 1, 1);
		}

		// Ambient
		vec3 lightColour = vec3(1, 1, 1);
		vec3 objectColour = vec3(1, 0, 0);
		float ambientStrength = 0.3f;
		vec3 ambient = ambientStrength * lightColour;

		// Diffuse 
		vec3 norm = normalize(faceNormal);
		vec3 lightDir = normalize(lightPos - intersect);
		float diff = max(dot(norm, lightDir), 0.0);
		vec3 diffuse = diff * lightColour;

		vec3 result = (ambient + diffuse) * objectColour;
		vec4 colour = vec4(result, 1.0f);

		return colour;
    
	}

	float t;
	if(intersectTriangles(origin, dir, t))
	{
		return vec4(1, 0, 0, 1);
	}

	return vec4(0.5, 0.5, 0.5, 1.0); //vec4(dir, 1); //
}

layout (local_size_x = 16, local_size_y = 8) in;
void main(void) {
	ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
	ivec2 size = imageSize(framebuffer);
	if (pix.x >= size.x || pix.y >= size.y) {
	return;
	}
	vec2 pos = vec2(pix) / vec2(size.x - 1, size.y - 1);
	vec3 dir = mix(mix(ray00, ray01, pos.y), mix(ray10, ray11, pos.y), pos.x);
	vec4 color = trace(eye, dir);
	imageStore(framebuffer, pix, color);
}
